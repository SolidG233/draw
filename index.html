<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æé€Ÿä½ ç”»æˆ‘çŒœ (åœ°ç‹±éš¾åº¦ç‰ˆ)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.5.2/peerjs.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #f0f2f5; display: flex; flex-direction: column; align-items: center; padding: 10px; margin: 0; }
        
        /* é¡¶éƒ¨ */
        header { width: 100%; max-width: 1000px; background: #fff; padding: 15px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); margin-bottom: 15px; display: flex; justify-content: space-between; align-items: center; }
        h1 { margin: 0; font-size: 22px; color: #333; }
        
        /* æ¸¸æˆæ ¸å¿ƒåŒº */
        #game-container { display: flex; gap: 15px; width: 100%; max-width: 1000px; height: 600px; }
        
        /* å·¦ä¾§ç”»æ¿åŒº */
        #left-panel { flex: 2; display: flex; flex-direction: column; gap: 10px; position: relative; }
        
        #canvas-wrapper { position: relative; flex: 1; background: #fff; border: 2px solid #333; border-radius: 4px; display: flex; justify-content: center; align-items: center; overflow: hidden; }
        canvas { display: block; touch-action: none; }
        
        /* ç”»å»Šè§†å›¾ (æœ€åå±•ç¤ºç”¨) */
        #gallery-view { 
            display: none; flex: 1; background: #fff; border-radius: 4px; padding: 10px; 
            flex-wrap: wrap; gap: 10px; justify-content: center; overflow-y: auto; align-content: flex-start;
        }
        .gallery-item { width: 30%; height: 150px; border: 1px solid #ccc; position: relative; display: flex; flex-direction: column; }
        .gallery-item img { width: 100%; height: 100%; object-fit: contain; background: white; }
        .gallery-item .label { position: absolute; top: 0; left: 0; background: #007bff; color: white; padding: 2px 6px; font-size: 12px; }
        .gallery-item .answer { background: #28a745; color: white; text-align: center; font-weight: bold; padding: 5px; display: none; }
        .gallery-item.solved .answer { display: block; }
        .gallery-item.solved { border: 2px solid #28a745; }

        /* é®ç½©ä¸æç¤º */
        #blocker { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.1); z-index: 10; display: none; cursor: not-allowed; }
        
        #status-overlay { 
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%); 
            background: rgba(0,0,0,0.8); color: white; padding: 10px 20px; 
            border-radius: 30px; font-size: 20px; font-weight: bold; pointer-events: none; z-index: 20; text-align: center;
            min-width: 200px;
        }
        #timer-display { font-size: 40px; color: #ffeb3b; display: block; margin-top: 5px; font-weight: 900; }

        /* å³ä¾§èŠå¤© */
        #right-panel { flex: 1; display: flex; flex-direction: column; gap: 10px; }
        #player-list { background: #fff; padding: 10px; border-radius: 8px; min-height: 80px; }
        .p-card { padding: 5px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; font-size: 14px; }
        .p-card .role-badge { font-weight: bold; padding: 2px 5px; border-radius: 4px; font-size: 12px; }
        .role-P1 { background: #ffeeba; color: #856404; }
        .role-P2 { background: #d4edda; color: #155724; }
        .role-P3 { background: #cce5ff; color: #004085; }
        .role-OBS { background: #e2e3e5; color: #383d41; }

        #chat-box { flex: 1; background: #fff; border-radius: 8px; display: flex; flex-direction: column; overflow: hidden; }
        #messages { flex: 1; overflow-y: auto; padding: 10px; background: #f9f9f9; }
        .msg { margin-bottom: 6px; font-size: 14px; }
        .msg.sys { color: #888; text-align: center; font-style: italic; margin: 10px 0; }
        .msg.win { background: #d4edda; color: #155724; padding: 5px; text-align: center; border-radius: 4px; font-weight: bold; }
        
        #input-area { padding: 10px; display: flex; gap: 5px; border-top: 1px solid #eee; }
        input[type=text] { flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px; }
        button { padding: 8px 15px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; }

        /* è¿æ¥é¢æ¿ */
        #conn-panel { background: #fff; padding: 15px; border-radius: 8px; margin-bottom: 10px; }

        /* æˆ¿ä¸»å‡ºé¢˜å¼¹çª— */
        #host-input-modal { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); 
            z-index: 100; display: none; justify-content: center; align-items: center; 
        }
        .modal-content { background: white; padding: 20px; border-radius: 8px; width: 300px; }
        .modal-content input { width: 100%; margin-bottom: 10px; box-sizing: border-box; }
        
        select { padding: 8px; border-radius: 4px; border: 1px solid #ddd; }
    </style>
</head>
<body>

<header>
    <div>
        <h1>âš¡ æé€Ÿè¿ç”» (åœ°ç‹±éš¾åº¦ç‰ˆ)</h1>
        <div style="font-size:12px; color:#666;">è§„åˆ™: P2è¿ç»­ç”»5å¼ (æ¯å¼ 2ç§’)ï¼Œæœ€åæ‰€æœ‰P3çœ‹å›¾æŠ¢ç­”</div>
    </div>
    <div id="my-role-display">ç­‰å¾…è¿æ¥...</div>
</header>

<div id="conn-panel">
    <div id="setup-box">
        <label>æ˜µç§°:</label> <input type="text" id="nickname" value="ç©å®¶" style="width:80px">
        
        <!-- è§’è‰²é€‰æ‹©ä¸‹æ‹‰æ¡† -->
        <select id="role-select">
            <option value="P2">æˆ‘æƒ³å½“: ç”»æ‰‹ (P2 - é™1äºº)</option>
            <option value="P3">æˆ‘æƒ³å½“: çŒœé¢˜ (P3 - ä¸é™äººæ•°)</option>
            <option value="OBS">è§‚ä¼—</option>
        </select>

        <button onclick="createRoom()" style="background:#6c757d;">æˆ‘æ˜¯æˆ¿ä¸»(P1 å‡ºé¢˜)</button>
        <div style="margin: 10px 0; border-top:1px dashed #ccc;"></div>
        <input type="text" id="host-id" placeholder="è¾“å…¥æˆ¿ä¸»ID">
        <button onclick="joinRoom()">åŠ å…¥æˆ¿é—´</button>
    </div>
    <div id="id-info" style="margin-top:5px; color:#007bff; font-weight:bold;"></div>
</div>

<div id="game-container">
    <div id="left-panel">
        <!-- ç”»å¸ƒæ¨¡å¼ -->
        <div id="canvas-wrapper">
            <canvas id="canvas" width="600" height="450"></canvas>
            <div id="blocker"></div>
            <div id="status-overlay" style="display:none;">
                <div id="overlay-text">ç­‰å¾…å¼€å§‹</div>
                <div id="timer-display"></div>
            </div>
        </div>
        <!-- ç”»å»Šæ¨¡å¼ (æœ€åæ˜¾ç¤º) -->
        <div id="gallery-view"></div>

        <div style="display:flex; gap:10px; justify-content:center; margin-top:5px;">
            <button onclick="clearCanvas()">æ¸…ç©ºç”»æ¿</button>
        </div>
    </div>

    <div id="right-panel">
        <div id="player-list">
            <div style="font-weight:bold; margin-bottom:5px;">ç©å®¶åˆ—è¡¨:</div>
            <div id="p-list-content">ç­‰å¾…åŠ å…¥...</div>
        </div>
        <div id="chat-box">
            <div id="messages"></div>
            <div id="input-area">
                <input type="text" id="msg-input" placeholder="è¾“å…¥çŒœæµ‹..." onkeypress="if(event.key==='Enter') sendChat()">
                <button onclick="sendChat()">å‘é€</button>
            </div>
        </div>
    </div>
</div>

<!-- æˆ¿ä¸»è¾“å…¥è¯è¯­çš„å¼¹çª— -->
<div id="host-input-modal">
    <div class="modal-content">
        <h3>P1 è¯·å‡ºé¢˜ (5ä¸ªè¯)</h3>
        <input type="text" id="word1" placeholder="è¯è¯­ 1">
        <input type="text" id="word2" placeholder="è¯è¯­ 2">
        <input type="text" id="word3" placeholder="è¯è¯­ 3">
        <input type="text" id="word4" placeholder="è¯è¯­ 4">
        <input type="text" id="word5" placeholder="è¯è¯­ 5">
        <button onclick="submitWords()" style="width:100%; background:#dc3545; color:white; font-weight:bold;">å¼€å§‹åœ°ç‹±çº§2ç§’æŒ‘æˆ˜ï¼</button>
    </div>
</div>

<script>
    // --- æ¸¸æˆé…ç½® (å·²ä¿®æ”¹) ---
    const DRAW_TIME = 2;    // ç”»ç”»æ—¶é—´æ”¹ä¸º 2 ç§’
    const PREPARE_TIME = 1; // å‡†å¤‡æ—¶é—´æ”¹ä¸º 1 ç§’
    
    // --- çŠ¶æ€å˜é‡ ---
    let peer = null;
    let myId = null;
    let myName = "ç©å®¶";
    let myRoleTag = "OBS"; // P1, P2, P3, OBS
    let isHost = false;
    let connections = []; 
    let hostConn = null;  
    
    // ç©å®¶æ•°æ®ç»“æ„: { id, name, roleName, roleTag }
    let players = []; 
    
    // æ¸¸æˆæ•°æ®
    let gameWords = [];
    let savedImages = []; 
    let currentWordIndex = 0;
    let timerInterval = null;
    let isGameRunning = false;
    let isGalleryPhase = false; 
    let solvedIndices = []; 

    // ç”»å¸ƒ
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let isDrawing = false;

    // --- è¾…åŠ©å‡½æ•°ï¼šè·å–ç‰¹å®šè§’è‰²çš„ç©å®¶ ---
    function getP2() { return players.find(p => p.roleTag === 'P2'); }
    function hasP3() { return players.some(p => p.roleTag === 'P3'); }

    // --- 1. ç½‘ç»œè¿æ¥ ---
    function initPeer() {
        peer = new Peer(null, { debug: 1 });
        peer.on('open', id => {
            myId = id;
            document.getElementById('id-info').innerText = `ID: ${id}`;
        });
        peer.on('error', err => alert("è¿æ¥é”™è¯¯:" + err.type));
    }

    function createRoom() {
        myName = document.getElementById('nickname').value + " (P1)";
        isHost = true;
        myRoleTag = 'P1';
        initPeer();
        // æˆ¿ä¸»é»˜è®¤P1
        players = [{ id: 'HOST', name: myName, roleName: 'å‡ºé¢˜è€…', roleTag: 'P1' }];
        updateUI();
        document.getElementById('setup-box').innerHTML = `<b>æˆ¿é—´å·²åˆ›å»ºï¼ç­‰å¾…ç©å®¶åŠ å…¥...</b> <button onclick="copyId()">å¤åˆ¶ID</button>`;
        
        peer.on('connection', conn => {
            conn.on('open', () => {
                connections.push(conn);
                conn.on('data', data => handleHostData(data, conn));
            });
        });
    }

    function joinRoom() {
        const hostId = document.getElementById('host-id').value;
        if(!hostId) return alert("è¯·è¾“å…¥æˆ¿ä¸»ID");
        
        myName = document.getElementById('nickname').value;
        const roleReq = document.getElementById('role-select').value; // è·å–è¯·æ±‚çš„è§’è‰²
        
        isHost = false;
        initPeer();
        document.getElementById('setup-box').innerHTML = `æ­£åœ¨è¿æ¥...`;

        setTimeout(() => {
            hostConn = peer.connect(hostId);
            hostConn.on('open', () => {
                document.getElementById('setup-box').innerHTML = `<b style="color:green">å·²åŠ å…¥ï¼</b>`;
                // å‘é€åŠ å…¥è¯·æ±‚ï¼Œå¸¦ä¸Šæƒ³è¦çš„è§’è‰²
                hostConn.send({ type: 'join', name: myName, roleReq: roleReq });
            });
            hostConn.on('data', handleClientData);
        }, 1000);
    }

    function copyId() { navigator.clipboard.writeText(myId); }

    // --- 2. æˆ¿ä¸»é€»è¾‘ (æ ¸å¿ƒæ§åˆ¶) ---

    function handleHostData(data, conn) {
        if (data.type === 'join') {
            // è§’è‰²åˆ†é…é€»è¾‘
            let assignedRoleName = 'è§‚ä¼—';
            let assignedRoleTag = 'OBS';
            let warningMsg = '';

            // æ£€æŸ¥P2æ˜¯å¦è¢«å ç”¨
            const isP2Taken = players.some(p => p.roleTag === 'P2');
            
            if (data.roleReq === 'P2') {
                if (!isP2Taken) {
                    assignedRoleName = 'ç”»æ‰‹ (P2)';
                    assignedRoleTag = 'P2';
                } else {
                    warningMsg = '(P2å·²æ»¡ï¼Œè‡ªåŠ¨è½¬ä¸ºè§‚ä¼—)';
                }
            } else if (data.roleReq === 'P3') {
                assignedRoleName = 'çŒœé¢˜ (P3)';
                assignedRoleTag = 'P3';
            }

            players.push({ id: conn.peer, name: data.name, roleName: assignedRoleName, roleTag: assignedRoleTag });
            
            // å¹¿æ’­ç©å®¶åˆ—è¡¨æ›´æ–°
            broadcast({ type: 'update_players', players: players });
            broadcast({ type: 'chat', name: 'ç³»ç»Ÿ', msg: `${data.name} åŠ å…¥äº†æˆ¿é—´ ${warningMsg}`, isSys: true });
            
            // å‘Šè¯‰æ–°æ¥çš„ç©å®¶ä»–æ˜¯è°
            conn.send({ type: 'you_are', roleTag: assignedRoleTag });

            // å¦‚æœP2å°±ä½ï¼Œä¸”è‡³å°‘æœ‰ä¸€ä¸ªP3ï¼Œæç¤ºæˆ¿ä¸»å¼€å§‹
            if (getP2() && hasP3() && !isGameRunning) {
                document.getElementById('host-input-modal').style.display = 'flex';
            }
        }
        
        if (data.type === 'draw' || data.type === 'clear') {
            // åªæœ‰P2èƒ½ç”»
            const p2 = getP2();
            if (p2 && conn.peer === p2.id) {
                // æˆ¿ä¸»è‡ªå·±ç”»
                if(data.type === 'draw') drawLocal(data.x, data.y, data.isStart);
                else ctx.clearRect(0,0,canvas.width, canvas.height);
            }
        }

        if (data.type === 'chat') {
            broadcast({ type: 'chat', name: data.name, msg: data.msg });
            if (isGalleryPhase) checkGuess(data.msg, data.name);
        }
    }

    function submitWords() {
        if(!getP2() || !hasP3()) return alert("éœ€è¦ P2(ç”»æ‰‹) å’Œ è‡³å°‘ä¸€ä½ P3(çŒœé¢˜) æ‰èƒ½å¼€å§‹ï¼");

        const inputs = [1,2,3,4,5].map(i => document.getElementById('word'+i).value.trim());
        if (inputs.some(w => !w)) return alert("è¯·å¡«æ»¡5ä¸ªè¯ï¼");
        
        gameWords = inputs;
        savedImages = [];
        solvedIndices = [];
        document.getElementById('host-input-modal').style.display = 'none';
        
        isGameRunning = true;
        isGalleryPhase = false;
        currentWordIndex = -1;
        
        broadcast({ type: 'chat', name: 'ç³»ç»Ÿ', msg: `æ¸¸æˆå¼€å§‹ï¼P2å°†è¿ç»­ç”»5å¼ å›¾ï¼Œæ¯å¼ åªæœ‰${DRAW_TIME}ç§’ï¼`, isSys: true });
        
        nextWord();
    }

    function nextWord() {
        currentWordIndex++;
        clearInterval(timerInterval);

        if (currentWordIndex >= 5) {
            startGalleryPhase();
            return;
        }

        const word = gameWords[currentWordIndex];
        let prepTime = PREPARE_TIME;
        broadcastState('prepare', word, prepTime); 
        
        timerInterval = setInterval(() => {
            prepTime--;
            if (prepTime > 0) {
                broadcastState('prepare', word, prepTime);
            } else {
                clearInterval(timerInterval);
                startDrawingPhase(word);
            }
        }, 1000);
    }

    function startDrawingPhase(word) {
        ctx.clearRect(0,0,canvas.width, canvas.height);
        
        // æ‰¾åˆ°P2çš„è¿æ¥å¹¶é€šçŸ¥æ¸…ç©º
        const p2 = getP2();
        const p2Conn = connections.find(c => c.peer === p2.id);
        if(p2Conn) p2Conn.send({ type: 'clear' }); 

        let drawTime = DRAW_TIME;
        broadcastState('drawing', word, drawTime);

        timerInterval = setInterval(() => {
            drawTime--;
            if (drawTime >= 0) {
                broadcastState('drawing', word, drawTime);
            } else {
                clearInterval(timerInterval);
                const imgData = canvas.toDataURL("image/png");
                savedImages.push(imgData);
                broadcast({ type: 'chat', name: 'ç³»ç»Ÿ', msg: `ç¬¬ ${currentWordIndex+1} å¼ å›¾å·²ä¿å­˜ï¼`, isSys: true });
                setTimeout(nextWord, 1000);
            }
        }, 1000);
    }

    function startGalleryPhase() {
        isGalleryPhase = true;
        broadcast({ type: 'chat', name: 'ç³»ç»Ÿ', msg: 'ğŸ”¥ ä½œç”»ç»“æŸï¼è¯·çœ‹å›¾æŠ¢ç­”ï¼', isSys: true });
        
        const galleryData = { type: 'show_gallery', images: savedImages };
        broadcast(galleryData, 'HOST'); 
        handleClientData(galleryData); 
    }

    function checkGuess(msg, playerName) {
        let newSolve = false;
        gameWords.forEach((word, idx) => {
            if (solvedIndices.includes(idx)) return;
            if (msg.includes(word)) {
                solvedIndices.push(idx);
                newSolve = true;
                const winMsg = `ğŸ‰ ${playerName} çŒœå¯¹äº†ç¬¬ ${idx+1} é¢˜ï¼šã€${word}ã€‘`;
                broadcast({ 
                    type: 'solve_word', index: idx, word: word,
                    msg: winMsg
                });
                updateGalleryItem(idx, word);
                addMsg('ç³»ç»Ÿ', winMsg, false, true);
            }
        });

        if (solvedIndices.length === 5) {
            broadcast({ type: 'chat', name: 'ç³»ç»Ÿ', msg: 'ğŸ† å…¨éƒ¨é¢˜ç›®å·²è¢«æ”»å…‹ï¼æ¸¸æˆç»“æŸï¼', isWin: true });
            isGameRunning = false;
        }
    }

    function broadcastState(phase, word, time) {
        const data = {
            type: 'state_update',
            phase: phase,
            time: time,
            word: word,
            index: currentWordIndex + 1
        };
        
        updateGameUI(data); // æˆ¿ä¸»UI

        // éå†è¿æ¥åˆ†å‘
        connections.forEach(conn => {
            const p = players.find(pl => pl.id === conn.peer);
            if (!p) return;

            // P3 å’Œ è§‚ä¼— åœ¨ä½œç”»é˜¶æ®µçœ‹ä¸åˆ°è¯
            if (p.roleTag === 'P3' || p.roleTag === 'OBS') {
                conn.send({...data, word: '???'});
            } else {
                // P2 èƒ½çœ‹åˆ°è¯
                conn.send(data);
            }
        });
    }

    function broadcast(data, excludeId) {
        connections.forEach(c => {
            if(c.peer !== excludeId) c.send(data);
        });
        if (isHost && excludeId !== 'HOST') {
            if(data.type === 'update_players') updateUI();
            if(data.type === 'chat') addMsg(data.name, data.msg, data.isSys, data.isWin);
        }
    }

    // --- 3. å®¢æˆ·ç«¯é€»è¾‘ ---

    function handleClientData(data) {
        if (data.type === 'you_are') {
            myRoleTag = data.roleTag; // ç¡®è®¤è‡ªå·±çš„è§’è‰²
        }
        if (data.type === 'update_players') {
            players = data.players;
            updateUI();
        }
        if (data.type === 'chat') addMsg(data.name, data.msg, data.isSys, data.isWin);
        
        // P2 æœ¬åœ°ç”»ç”»å›æ˜¾
        if (data.type === 'draw') drawLocal(data.x, data.y, data.isStart);
        if (data.type === 'clear') ctx.clearRect(0,0,canvas.width, canvas.height);
        
        if (data.type === 'state_update') updateGameUI(data);
        
        if (data.type === 'show_gallery') renderGallery(data.images);
        
        if (data.type === 'solve_word') {
            updateGalleryItem(data.index, data.word);
            addMsg('ç³»ç»Ÿ', data.msg, false, true);
        }
    }

    // --- 4. UI æ›´æ–° ---

    function renderGallery(images) {
        document.getElementById('canvas-wrapper').style.display = 'none';
        const gView = document.getElementById('gallery-view');
        gView.style.display = 'flex';
        gView.innerHTML = images.map((src, i) => `
            <div class="gallery-item" id="g-item-${i}">
                <div class="label">#${i+1}</div>
                <img src="${src}">
                <div class="answer" id="ans-${i}">???</div>
            </div>
        `).join('');
    }

    function updateGalleryItem(index, word) {
        const item = document.getElementById(`g-item-${index}`);
        const ans = document.getElementById(`ans-${index}`);
        if(item && ans) {
            item.classList.add('solved');
            ans.innerText = word;
        }
    }

    function updateUI() {
        // æ›´æ–°é¡¶éƒ¨è§’è‰²æ˜¾ç¤º
        const myP = players.find(p => p.id === (isHost ? 'HOST' : myId));
        const roleStr = myP ? myP.roleName : 'æœªçŸ¥';
        document.getElementById('my-role-display').innerHTML = `æˆ‘æ˜¯: <b>${roleStr}</b>`;

        // æ›´æ–°åˆ—è¡¨
        const html = players.map(p => `
            <div class="p-card">
                <span>${p.name}</span>
                <span class="role-badge role-${p.roleTag}">${p.roleName}</span>
            </div>
        `).join('');
        document.getElementById('p-list-content').innerHTML = html;
    }

    function updateGameUI(data) {
        document.getElementById('canvas-wrapper').style.display = 'flex';
        document.getElementById('gallery-view').style.display = 'none';

        const overlay = document.getElementById('status-overlay');
        const text = document.getElementById('overlay-text');
        const timer = document.getElementById('timer-display');
        const blocker = document.getElementById('blocker');
        
        overlay.style.display = 'block';
        timer.innerText = data.time;
        
        const amIDrawer = (myRoleTag === 'P2');

        if (data.phase === 'prepare') {
            overlay.style.background = 'rgba(0,0,0,0.9)';
            text.innerHTML = `ç¬¬ ${data.index}/5 é¢˜<br>å‡†å¤‡! é¢˜ç›®: <span style="color:#ff5722; font-size:24px">${data.word}</span>`;
            blocker.style.display = 'block'; 
        } else if (data.phase === 'drawing') {
            if (amIDrawer) {
                overlay.style.background = 'rgba(0,128,0,0.1)'; 
                overlay.style.pointerEvents = 'none';
                text.innerHTML = `ğŸ”¥ åªæœ‰${DRAW_TIME}ç§’! ç”»: ${data.word}`;
                timer.style.color = 'red';
                blocker.style.display = 'none';
            } else {
                overlay.style.background = 'rgba(0,0,0,0.95)'; 
                text.innerHTML = `P2 æ­£åœ¨æé€Ÿä½œç”»... (ç¬¬ ${data.index} å¼ )`;
                blocker.style.display = 'block';
            }
        }
    }

    function addMsg(name, msg, isSys, isWin) {
        const div = document.createElement('div');
        div.className = `msg ${isSys?'sys':''} ${isWin?'win':''}`;
        div.innerHTML = (isSys||isWin) ? msg : `<b>${name}:</b> ${msg}`;
        const box = document.getElementById('messages');
        box.appendChild(div);
        box.scrollTop = box.scrollHeight;
    }

    function sendChat() {
        const input = document.getElementById('msg-input');
        const val = input.value.trim();
        if(!val) return;
        
        if (isHost) {
            broadcast({ type: 'chat', name: myName, msg: val });
            if(isGalleryPhase) checkGuess(val, myName);
            addMsg(myName, val);
        } else {
            hostConn.send({ type: 'chat', msg: val, name: myName });
        }
        input.value = '';
    }

    // --- 5. ç”»æ¿é€»è¾‘ ---
    function getPos(e) {
        const rect = canvas.getBoundingClientRect();
        const t = e.changedTouches ? e.changedTouches[0] : e;
        return { x: t.clientX - rect.left, y: t.clientY - rect.top };
    }

    function startDraw(e) {
        if (!isDrawing && myRoleTag === 'P2') { 
            isDrawing = true;
            const p = getPos(e);
            drawLocal(p.x, p.y, true);
            if(!isHost) hostConn.send({ type: 'draw', x: p.x, y: p.y, isStart: true });
        }
    }

    function moveDraw(e) {
        if (!isDrawing) return;
        e.preventDefault();
        const p = getPos(e);
        drawLocal(p.x, p.y, false);
        if(!isHost) hostConn.send({ type: 'draw', x: p.x, y: p.y, isStart: false });
    }

    function stopDraw() { isDrawing = false; }

    function drawLocal(x, y, isStart) {
        ctx.lineWidth = 4;
        ctx.lineCap = 'round';
        ctx.strokeStyle = '#000';
        if (isStart) { ctx.beginPath(); ctx.moveTo(x, y); }
        else { ctx.lineTo(x, y); ctx.stroke(); }
    }
    
    function clearCanvas() {
        if (myRoleTag === 'P2') {
            ctx.clearRect(0,0,canvas.width, canvas.height);
            hostConn.send({ type: 'clear' });
        }
    }

    canvas.addEventListener('mousedown', startDraw);
    canvas.addEventListener('mousemove', moveDraw);
    canvas.addEventListener('mouseup', stopDraw);
    canvas.addEventListener('mouseout', stopDraw);
    canvas.addEventListener('touchstart', startDraw);
    canvas.addEventListener('touchmove', moveDraw);
    canvas.addEventListener('touchend', stopDraw);

</script>
</body>
</html>
